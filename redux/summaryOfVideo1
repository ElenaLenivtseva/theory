redux нужен, чтобы не поднимать состояние и не прокидывать миллион пропсов.Ведь часто инфа нужна то в верху дерева, то внизу, нужно поднимать стейт. Это пропс дрилин.

Redux предлагает общее хранилище, где лежит весь стейт. Ничего не нужно прокидывать. Но есть другие сложности. Первое: ничто не может пройти мимо стора. И каждый раз к нему нужно обращаться: говоришь, что должно произойти(action), потом функция dispatch "несет" эту весточку редьюсерам, которые, в общем-то единственные реально что-то делают, редьюсеры решают, что надо сделать, основыеваясь на том, что произошло, меняют стейт(не мутируют, просто возвращают новый на основе старого, с учетом действия юзера), все возвращется новый стор, н которого подписны компоненты. компоненты такие "ага", стор поменялся, ребята, перерисовываемся.

Redux вообще просто менеджер по управлению состоянием. Он не привязан к React, но чаще всего они вместе идут. И даже можно сделать, как автор этого видео npm i redux react-redux, чтобы появились  некоторые упрощающие все фишки. Как я поняла из разных видео, вообще много всякого такого есть в redux. redux toolkit, redux saga и пр.


чтобы создать стор
import {createStore} from 'redux'
let store = createStore(reducer)

reducer нужно соответсвенно создать, импортнуть сюда, поместить в параметры функции по созданию стора. Важно: там может быть ток 1 редьюсер. Что если их большше? Combine их всех в один большой редьюсер.

чтобы создать action
это если что просто функция, котрая возвращает объект. Да в redux все по сути объекты
Что в action? type как минимум. и это просто строка. Обычно капсом. ну можно, конечно, заморочиться, вынести строку в переменную. А еще можно создать action creator, но в этом видео, по-моему об этом не рассказывается.
const increment = () => {
    return {
        type: 'INCREMENT'
    }
}
Еще мб какая-то доп инфа, ее можно назвть как угодно, но чаще всего зовут payload


чтобы создать редьюсер
это тоже функция, которая возвращает объект
на входе 2 параметра принимает: текущее состояние. Это мб число, кк унас, но обычно это, угадай что, объект конечно. И второй параметр - action. Чтобы понять, что делать, надо получить эту "весточку". И чаще всего юзается switch, ведь action.type мб разным
const counter = (state = 0, action) => {
    switch(action.type){
        case: 'INCREMENT':
        return state+1
    }
}
тут правда мутация...

let store = createStore(counter)


чтобы компоненты подписались на изменения стора
store.subscribe(()=>console.log(store.getState()))


чтобы dispatch (ведь без него ничего не работает)
store.dispatch(increment())

но почему мы вызываем функцию сразу???


ссоздал папку reducers, в ней index.js, counter.js, loggedIn. Почему? Потому что таких штук, как counter мб хоть 200. В index он их просто скомбйнит и экспортнет.

counter.js
Смотри, сразу создали дефолтное значение стейта, при первичном рендеринге не крашнется. и добавили дефолт
const counterReducer = (state = 0, action) {
    switch(action.type) {
        case: 'INCREMENT':
            return state+1
        case: 'DECREMENT':
            return state-1
        defaut:
            return state;
    }
}

loggedIn.js
const isLoggedReducer = (state = false, action) {
    switch(action.type) {
        case: 'SIGN_IN':
            return !state
    }
}
В том индексе импортнул все редьюсеры
import {combineReducers} from 'redux'
combineReducers оже возвращает объект, ключи м называть, как хочешь
const allReducers = combineReducers({
    counter: counterReducer,
    isLogged: isLoggedReducer
})

store создал в самом главном index.js, в корневом прям
import {createStore} from 'redux'
в функцию поместил общий редьюсер



redux dev tools - расширение, которое можно установить миллионом способов
основной - запихнуть строчку в функцию по созданию стора. как я смотрю, это вообще любимое место,куда все помещают. applyMiddleWare(как-то так называется) то же туда помещается

Эти девтулы причина легкой тестируемости, потому что можно перемещаться на любое кол-во шагов назад, прыгать, смотреть стейт на разных шагах


Штука из react-redux для связи этого всего с компонентами - Provider
import {Provider} from 'react-redux'
А потом все заверни в Provider, т.е. сам корневой элемент в render, сам App т.е. заверни


Вторая штука из react-redux - хук useSelector
import {useSelector} from 'react-redux'
const counter = useSelector(state=>state.counter)
<h1>{counter}</h1>
Эта штука нужна, чтоб сразу достать из стора конкретный стейт. Типо как к объекту ты обращаешься, только тут видимо фишка в том, что вызывается перерендер при изменении. ведь в реакт если просто менять объекты, ему плевать на это, нужно показать, что это важно для UI



изменения стейта
Сначала зайди в actions
Там насоздавай функций, возвращающих объекты

const increment =()=> {
    return{
        type: 'INCREMENT',
    }
}

пОТОМ ЭКСПОРТНИ И ПРИМЕНИ ТАМ ГДЕ РАЗМЕТКА
ТАМ ЖЕ импорти хук useDispatch из react-redux
потом внутри компоненты 
const dispatch = useDispatch()
(вот тут не поняла. Зачем мы берем хук из react-redux и даем ему имя как в обычном redux??)
<button onClick={()=>dispatch(increment())}>+</button>

и опять, посмотри не колбек, а вызов функции. непонятно

про payload
разметка
<button onClick={()=>dispatch(increment(5))}>+</button>

теперь понятно, почему вызов, норм

action creator
const increment =(number)=> {
    return{
        type: 'INCREMENT',
        payload: number
    }
}

reducer. action же объект
const counterReducer = (state = 0, action) {
    switch(action.type) {
        case: 'INCREMENT':
            return state+action.payload
        case: 'DECREMENT':
            return state-action.payload
        defaut:
            return state;
    }
}