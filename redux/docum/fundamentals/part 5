Redux Fundamentals, Part 5: UI and React
you can use Redux with any UI framework (or even without any UI framework), and use it on both client and server. You can write Redux apps with React, Vue, Angular, Ember, jQuery, or vanilla JavaScript.
That said, Redux was specifically designed to work well with React.
База использования редакс
Без привязки
// 1) Create a new Redux store with the `createStore` function
const store = Redux.createStore(counterReducer)

// 2) Subscribe to redraw whenever the data changes in the future
store.subscribe(render)

// Our "user interface" is some text in a single HTML element
const valueEl = document.getElementById('value')

// 3) When the subscription callback runs:
function render() {
// 3.1) Get the current store state
const state = store.getState()
// 3.2) Extract the data you want
const newValue = state.value.toString()

// 3.3) Update the UI with the new value
valueEl.innerHTML = newValue
}

// 4) Display the UI with the initial store state
render()

// 5) Dispatch actions based on UI inputs
document.getElementById('increment').addEventListener('click', function () {
store.dispatch({ type: 'counter/incremented' })
})
Using Redux with React
npm install react-redux
Тут уже пошли примеры с текущим приложением
Reading State from the Store with useSelector
Елена
Елена 23:43
selector is a function that takes the entire Redux store state as its argument, reads some value from the state, and returns that result.
const selectTodos = state => state.todos
Можно даже проводить какие-то манипуляции, без мутирования
const selectTotalCompletedTodos = state => {
const completedTodos = state.todos.filter(todo => todo.completed)
return completedTodos.length
}
Елена
Елена 23:51
useSelector automatically subscribes to the Redux store
If the value returned by the selector changes from the last time it ran, useSelector will force our component to re-render with the new dat
Но сравнение строгое
Т.е. если с типами не лады, будет ререндериться много раз
М еще
// Bad: always returning a new reference
const selectTodoDescriptions = state => {
// This creates a new array reference!
return state.todos.map(todo => todo.text)
}
Dispatching Actions with useDispatch
Гениальная разработка редакс
Нужно создать переменную с именем диспатч
И равна она результату вызова юздиспатч
Чтобы что?
Чтобы юзаьь просто диспатч
import React, { useState } from 'react'
import { useDispatch } from 'react-redux'

const Header = () => {
const [text, setText] = useState('')
const dispatch = useDispatch()

const handleChange = e => setText(e.target.value)

const handleKeyDown = e => {
const trimmedText = e.target.value.trim()
// If the user pressed the Enter key:
if (e.key === 'Enter' && trimmedText) {
// Dispatch the "todo added" action with this text
dispatch({ type: 'todos/todoAdded', payload: trimmedText })
// And clear out the text input
setText('')
}
}

return (
<input
type="text"
placeholder="What needs to be done?"
autoFocus={true}
value={text}
onChange={handleChange}
onKeyDown={handleKeyDown}
/>
)
}

export default Header
Passing the Store with Provider
Стор это как контекст в реакте
Его нужно обеспечить и как пропс дать родителю 
import React from 'react'
import ReactDOM from 'react-dom'
import { Provider } from 'react-redux'

import App from './App'
import store from './store'

ReactDOM.render(
// Render a `<Provider>` around the entire `<App>`,
// and pass the Redux store to it as a prop
<React.StrictMode>
<Provider store={store}>
<App />
</Provider>
</React.StrictMode>,
document.getElementById('root')
)
React-Redux Patterns
Global State, Component State, and Forms
Все пихать в стор?
Нет не все. Редакс кричит об этом. Например инпуты не соответствует кидать в стор
Типа какой теме tine-traveler debugger нужен?
Типо
П
Пе
Пет
Петя
Петя_2
Петя_24
И зачем это
А что надо тогда?
Очнись,вспомни мэйн проблем, которую решает редака
Одна и та же инфа нужна компонентам на разных уровнях в дереве
Ответь на эти вопросы и сможешь принять решение
Do other parts of the application care about this data?
Do you need to be able to create further derived data based on this original data?
Is the same data being used to drive multiple components?
Is there value to you in being able to restore this state to a given point in time (ie, time travel debugging)?
Do you want to cache the data (ie, use what's in state if it's already there instead of re-requesting it)?
Do you want to keep this data consistent while hot-reloading UI components (which may lose their internal state when swapped)?
28 марта
Елена
Елена 0:00
Using Multiple Selectors in a Component 
We can call useSelector multiple times within one component. In fact, this is actually a good idea - each call to useSelector should always return the smallest amount of state possible.
1 вызов- 1 кусок
Selecting Data in List Items by ID
Малочто пон
Какая то штука, чтоб проверять массивы мол равеы не равны пред и тек
There's a problem with this, though. We said earlier that returning new array references in selectors causes components to re-render every time, and right now we're returning a new IDs array in <TodoList>. In this case, the contents of the IDs array should be the same if we're toggling a todo, because we're still showing the same todo items - we haven't added or deleted any. But, the array containing those IDs is a new reference, so <TodoList> will re-render when it really doesn't need to.

One possible solution to this is to change how useSelector compares its values to see if they've changed. useSelector can take a comparison function as its second argument. A comparison function is called with the old and new values, and returns true if they're considered the same. If they're the same, useSelector won't make the component re-render.

React-Redux has a shallowEqual comparison function we can use to check if the items inside the array are still the same
import React from 'react'
import { useSelector, shallowEqual } from 'react-redux'
import TodoListItem from './TodoListItem'

const selectTodoIds = state => state.todos.map(todo => todo.id)

const TodoList = () => {
const todoIds = useSelector(selectTodoIds, shallowEqual)

const renderedListItems = todoIds.map(todoId => {
return <TodoListItem key={todoId} id={todoId} />
})

return <ul className="todo-list">{renderedListItems}</ul>
}

SUMMARY
Redux stores can be used with any UI layer
UI code always subscribes to the store, gets the latest state, and redraws itself
React-Redux is the official Redux UI bindings library for React
React-Redux is installed as a separate react-redux package
The useSelector hook lets React components read data from the store
Selector functions take the entire store state as an argument, and return a value based on that state
useSelector calls its selector function and returns the result from the selector
useSelector subscribes to the store, and re-runs the selector each time an action is dispatched.
Whenever the selector result changes, useSelector forces the component to re-render with the new data
The useDispatch hook lets React components dispatch actions to the store
useDispatch returns the actual store.dispatch function
You can call dispatch(action) as needed inside your components
The <Provider> component makes the store available to other React components
Render <Provider store={store}> around your entire <App